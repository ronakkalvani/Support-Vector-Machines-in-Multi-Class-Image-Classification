# -*- coding: utf-8 -*-
"""ass2Q2MultiClass.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/130CYjsuuHiV6DMiD1qDMOCJ_xJGViLZT
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import zipfile
import os
import cv2
import cvxopt
from cvxopt import solvers
from cvxopt import matrix
from sklearn import svm
from sklearn.svm import SVC
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import confusion_matrix

with zipfile.ZipFile('/content/drive/MyDrive/T/svm.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/svm')

Traindata= []
for FileName in os.listdir("/content/svm/train"):
    data= []
    CurrLoc= os.path.join("/content/svm/train", FileName)
    for ImageName in os.listdir(CurrLoc):
        Image= cv2.imread(os.path.join(CurrLoc, ImageName))
        Image= cv2.resize(Image, (16, 16))
        data.append((Image/255).flatten())
    Traindata.append(data)
Traindata= np.array(Traindata)
TrainImages= Traindata.reshape((len(Traindata)*len(Traindata[0]),len(Traindata[0,0])))
TrainClass= []
for i in range(len(Traindata)):
    for j in range(len(Traindata[0])):
        TrainClass.append([i])
TrainClass= np.array(TrainClass)

Valdata= []
for FileName in os.listdir("/content/svm/val"):
    data= []
    CurrLoc= os.path.join("/content/svm/val", FileName)
    for ImageName in os.listdir(CurrLoc):
        Image= cv2.imread(os.path.join(CurrLoc, ImageName))
        Image= cv2.resize(Image, (16, 16))
        data.append((Image/255).flatten())
    Valdata.append(data)
Valdata= np.array(Valdata)
ValImages= Valdata.reshape((len(Valdata)*len(Valdata[0]),len(Valdata[0][0])))
ValClass= []
for i in range(len(Valdata)):
    for j in range(len(Valdata[0])):
        ValClass.append([i])
ValClass= np.array(ValClass)

def KernelMat(data1,data2):
    m1,m2=len(data1),len(data2)
    K= np.zeros((m1,m2))
    for i in range(m1):
        for j in range(m2):
            K[i,j]= np.exp(-0.001*(np.linalg.norm(data1[i]-data2[j])**(2)))
    return K
def SvmUsingCvxoptKernel(data,labels,C):
    m= len(data)
    n= len(data[0])
    K= KernelMat(data,data)
    lab= np.diag(labels[:,0])
    P= lab @ K @ lab
    G= np.vstack([np.diag([-1]*m), np.diag([1]*m)])
    h= np.hstack([np.zeros(m), np.full(m,C)])
    q= np.full((m,1),-1)
    A= labels.T
    b= 0
    P= matrix(P,tc='d')
    G= matrix(G,tc='d')
    h= matrix(h,tc='d')
    q= matrix(q,tc='d')
    A= matrix(A,tc='d')
    b= matrix(b,tc='d')
    alphas= np.array(solvers.qp(P,q,G,h,A,b)['x'])
    for i in range(len(alphas)):
        if alphas[i]<C*(10**(-5)):
            alphas[i]= 0
    for i in range(len(alphas)):
        if alphas[i]>C*(1-10**(-5)):
            alphas[i]= C
    mx,mn= -np.inf, np.inf
    wTx= (alphas*labels).T @ K
    for i in range(m):
        current= wTx[0][i]
        if labels[i][0]==-1:
            if current>mx:
                mx= current
        else:
            if current<mn:
                mn= current
    b= -(mx+mn)/2
    return (b,alphas)

pairs= []
for i in range(6):
    for j in range(i+1,6):
        pairs.append((i,j))
print(pairs)

def PredictionSVM(Traindata,ValImages,ValClass,Cof,cvxopt):
    if cvxopt==True:
        PredVotes= np.zeros((len(ValImages),6))
        for pair in pairs:
            TrainImagesbin= np.vstack([Traindata[pair[0]],Traindata[pair[1]]])
            TrainClassbin= np.vstack([np.full((len(Traindata[0]),1),1),np.full((len(Traindata[0]),1),-1)])
            solution = SvmUsingCvxoptKernel(TrainImagesbin,TrainClassbin,Cof)
            b= solution[0]
            alphas= solution[1]
            KernelMatVal= KernelMat(TrainImagesbin,ValImages)
            Prediction= np.sign((alphas*TrainClassbin).T @ KernelMatVal + b).T
            for i in range(len(Prediction)):
                if Prediction[i][0]== 1:
                    PredVotes[i][pair[0]]+= 1
                else:
                    PredVotes[i][pair[1]]+= 1
        FinalPrediction= []
        for i in range(len(PredVotes)):
            mx= np.max(PredVotes[i])
            for j in range(5,-1,-1):
                if mx== PredVotes[i][j]:
                    FinalPrediction.append([j])
                    break
    else:
        SKlearnModel = svm.SVC(kernel='rbf', C=Cof)
        SKlearnModel.fit(TrainImages, TrainClass[:,0])
        FinalPrediction = SKlearnModel.predict(ValImages)
        FinalPrediction = FinalPrediction.reshape((len(FinalPrediction),1))
    return FinalPrediction

# FinalPrediction= PredictionSVM(Traindata,ValImages,ValClass,1,True)
# Accuracy= np.mean(FinalPrediction== ValClass)
# ConfMat= confusion_matrix(ValClass,FinalPrediction)
# print(FinalPrediction)
# print(Accuracy)
# print(ConfMat)

FinalPrediction= np.array(PredictionSVM(Traindata,ValImages,ValClass,1,False))
Accuracy= np.mean(FinalPrediction== ValClass)
ConfMat= confusion_matrix(ValClass,FinalPrediction)
print(FinalPrediction)
print(Accuracy)
print(ConfMat)

count=0
for i in range(len(FinalPrediction)):
    if count==12:
        break
    if FinalPrediction[i] != ValClass[i][0]:
        count+=1
        plt.figure()
        plt.title(f'Missclassified Image {count}')
        plt.imshow(ValImages[i].reshape((16, 16, 3)))
        plt.show()

kf = StratifiedKFold(n_splits= 5, shuffle=True, random_state=42)

AllCs= [10**(-5),10**(-3),1,5,10]
AccuracyForCs= []
for C in AllCs:
    Accuracies= []
    for big, small in kf.split(TrainImages,TrainClass):
        TrainPartImages, ValPartImages = TrainImages[big], TrainImages[small]
        TrainPartClass, ValPartClass = TrainClass[big], TrainClass[small]
        TrainPartdata= [[] for i in range(6)]
        for i in range(len(TrainPartImages)):
            TrainPartdata[TrainPartClass[i][0]].append(TrainPartImages[i])
        FinalPrediction= PredictionSVM(TrainPartdata,ValPartImages,ValPartClass,C,False)
        Accuracies.append(np.mean(FinalPrediction== ValPartClass))
        print(FinalPrediction)
        print(np.mean(FinalPrediction== ValPartClass))
    AccuracyForCs.append(np.mean(np.array(Accuracies)))
print(AccuracyForCs)
plt.figure()
plt.plot(np.log(AllCs),AccuracyForCs)
plt.title("K-Fold Accuracy over different C")
plt.xlabel("Log of Cs")
plt.ylabel("Accuracy")
plt.show()

AccuraciesVal = []
for C in AllCs:
    FinalPrediction= np.array(PredictionSVM(Traindata,ValImages,ValClass,C,False))
    AccuraciesVal.append(np.mean(FinalPrediction== ValClass))
    print(AccuraciesVal)
plt.figure()
plt.plot(np.log(AllCs),AccuraciesVal)
plt.title("Validation Accuracy over different C")
plt.xlabel("Log of Cs")
plt.ylabel("Accuracy")
plt.show()