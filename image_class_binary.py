# -*- coding: utf-8 -*-
"""ass2Q2Binary.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YUld33Lp5QCqc2qqEhK_9c2liI5MRmxR
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import zipfile
import os
import cv2
import cvxopt
from cvxopt import solvers
from cvxopt import matrix
from sklearn import svm
from sklearn.metrics import accuracy_score

with zipfile.ZipFile('/content/drive/MyDrive/T/svm.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/svm')

TrainImages= []
TrainClass= []
for ImageName in os.listdir("/content/svm/train/2"):
    Image= cv2.imread(os.path.join("/content/svm/train/2", ImageName))
    Image= cv2.resize(Image, (16, 16))
    TrainImages.append((Image/255).flatten())
    TrainClass.append([1])
for ImageName in os.listdir("/content/svm/train/3"):
    Image= cv2.imread(os.path.join("/content/svm/train/3", ImageName))
    Image= cv2.resize(Image, (16, 16))
    TrainImages.append((Image/255).flatten())
    TrainClass.append([-1])
TrainImages= np.array(TrainImages)
TrainClass= np.array(TrainClass)
mt= len(TrainImages)
nt= len(TrainClass)

ValImages= []
ValClass= []
for ImageName in os.listdir("/content/svm/val/2"):
    Image= cv2.imread(os.path.join("/content/svm/val/2", ImageName))
    Image= cv2.resize(Image, (16, 16))
    ValImages.append((Image/255).flatten())
    ValClass.append([1])
for ImageName in os.listdir("/content/svm/val/3"):
    Image= cv2.imread(os.path.join("/content/svm/val/3", ImageName))
    Image= cv2.resize(Image, (16, 16))
    ValImages.append((Image/255).flatten())
    ValClass.append([-1])
ValImages= np.array(ValImages)
ValClass= np.array(ValClass)
mv= len(ValImages)
nv= len(ValClass)

def SvmUsingCvxopt(data,labels,C):
    m= len(data)
    n= len(data[0])
    lab= np.diag(labels[:,0])
    P= lab @ data @ data.T @ lab
    G= np.vstack([np.diag([-1]*m), np.diag([1]*m)])
    h= np.hstack([np.zeros(m), np.full(m,C)])
    q= np.full((m,1),-1)
    A= np.array([[labels[i][0] for i in range(m)]])
    b= 0
    P= matrix(P,tc='d')
    G= matrix(G,tc='d')
    h= matrix(h,tc='d')
    q= matrix(q,tc='d')
    A= matrix(A,tc='d')
    b= matrix(b,tc='d')
    alphas= np.array(solvers.qp(P,q,G,h,A,b)['x'])
    for i in range(len(alphas)):
        if alphas[i]<C*(10**(-5)):
            alphas[i]= 0
    for i in range(len(alphas)):
        if alphas[i]>C*(1-10**(-5)):
            alphas[i]= C
    SupportVectors= []
    for i in range(len(alphas)):
        if alphas[i]>0:
            SupportVectors.append(i)
    w= (alphas*labels).T @ data
    mx,mn= -np.inf, np.inf
    wTx= w @ data.T
    for i in range(m):
        current= wTx[0][i]
        if labels[i][0]==-1:
            if current>mx:
                mx= current
        else:
            if current<mn:
                mn= current
    b= -(mx+mn)/2
    return (w,b,alphas,SupportVectors)

def KernelMat(data1,data2):
    m1,m2=len(data1),len(data2)
    K= np.zeros((m1,m2))
    for i in range(m1):
        for j in range(m2):
            K[i,j]= np.exp(-0.001*(np.linalg.norm(data1[i]-data2[j])**(2)))
    return K
def SvmUsingCvxoptKernel(data,labels,C):
    m= len(data)
    n= len(data[0])
    K= KernelMat(data,data)
    lab= np.diag(labels[:,0])
    P= lab @ K @ lab
    G= np.vstack([np.diag([-1]*m), np.diag([1]*m)])
    h= np.hstack([np.zeros(m), np.full(m,C)])
    q= np.full((m,1),-1)
    A= labels.T
    b= 0
    P= matrix(P,tc='d')
    G= matrix(G,tc='d')
    h= matrix(h,tc='d')
    q= matrix(q,tc='d')
    A= matrix(A,tc='d')
    b= matrix(b,tc='d')
    alphas= np.array(solvers.qp(P,q,G,h,A,b)['x'])
    for i in range(len(alphas)):
        if alphas[i]<C*(10**(-5)):
            alphas[i]= 0
    for i in range(len(alphas)):
        if alphas[i]>C*(1-10**(-5)):
            alphas[i]= C
    SupportVectors= []
    for i in range(len(alphas)):
        if alphas[i]>0:
            SupportVectors.append(i)
    mx,mn= -np.inf, np.inf
    wTx= (alphas*labels).T @ K
    for i in range(m):
        current= wTx[0][i]
        if labels[i][0]==-1:
            if current>mx:
                mx= current
        else:
            if current<mn:
                mn= current
    b= -(mx+mn)/2
    return (b,alphas,SupportVectors)

solution = SvmUsingCvxopt(TrainImages,TrainClass,1)
w= solution[0]
b= solution[1]
alphas= solution[2]
SupportVectors= solution[3]
print(len(SupportVectors),100*len(SupportVectors)/len(TrainImages))
Prediction= np.sign((w @ ValImages.T) + b).T
Accuracy= np.mean(Prediction== ValClass)
print(Accuracy)
SortedIndices= np.argsort(alphas[:,0])
for i in range(6):
    plt.subplot(2,3,i+1)
    plt.title(f'SV with coeff rank{i + 1}')
    plt.imshow(TrainImages[SortedIndices[-i-1]].reshape((16, 16, 3)))
plt.show()
plt.figure()
plt.title('Image of Weight Vector')
plt.imshow(w.reshape((16, 16, 3)))
plt.show()

solution = SvmUsingCvxoptKernel(TrainImages,TrainClass,1)
b= solution[0]
alphas= solution[1]
SupportVectorsKernel= solution[2]
print(len(SupportVectorsKernel),100*len(SupportVectorsKernel)/len(TrainImages))
KernelMatVal= KernelMat(TrainImages,ValImages)
Prediction= np.sign((alphas*TrainClass).T @ KernelMatVal + b).T
Accuracy= np.mean(Prediction== ValClass)
print(Accuracy)
SortedIndices= np.argsort(alphas[:,0])
for i in range(6):
    plt.subplot(2,3,i+1)
    plt.title(f'SV with coeff rank {i + 1}')
    plt.imshow(TrainImages[SortedIndices[-i-1]].reshape((16, 16, 3)))
plt.show()

CommonSvs=0
s=set(SupportVectorsKernel)
for sv in SupportVectors:
    if sv in s:
        CommonSvs+=1
print(CommonSvs)

SKlearnModel = svm.SVC(kernel='linear', C=1.0)
SKlearnModel.fit(TrainImages, TrainClass)
SupportVectorsSKlearn= SKlearnModel.support_
w = SKlearnModel.coef_.flatten()
b = SKlearnModel.intercept_[0]
Prediction = SKlearnModel.predict(ValImages)
Accuracy = np.mean(Prediction== ValClass[:,0])
CommonSvs=0
print(SupportVectorsSKlearn.shape)
s=set(SupportVectorsSKlearn)
for sv in SupportVectors:
    if sv in s:
        CommonSvs+=1
print(CommonSvs)
print(Accuracy)

SKlearnModel = svm.SVC(kernel='rbf', C=1.0)
SKlearnModel.fit(TrainImages, TrainClass)
SupportVectorsSKlearn= SKlearnModel.support_
Prediction = SKlearnModel.predict(ValImages)
Accuracy = np.mean(Prediction== ValClass[:,0])
CommonSvs=0
print(SupportVectorsSKlearn.shape)
s=set(SupportVectorsSKlearn)
for sv in SupportVectorsKernel:
    if sv in s:
        CommonSvs+=1
print(CommonSvs)
print(Accuracy)